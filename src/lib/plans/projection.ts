/**
 * Fitness Projection Calculator
 *
 * Projects CTL, ATL, and TSB forward through a training plan using
 * standard PMC exponential decay constants.
 *
 * CTL time constant (τ) = 42 days
 * ATL time constant (τ) = 7 days
 */

export interface PlanDayInput {
  date: string
  targetTSS: number
  workoutType?: string | null
  phase?: string | null
}

export interface ProjectionPoint {
  date: string
  ctl: number
  atl: number
  tsb: number
  /** TSS planned for this day */
  tss: number
  /** Whether this is an event day */
  isEvent?: boolean
  /** Whether this is a taper day */
  isTaper?: boolean
  /** Phase label (Base, Build, Peak, Taper) */
  phase?: string
}

export interface ProjectionResult {
  points: ProjectionPoint[]
  /** Projected fitness at end of plan */
  finalCTL: number
  finalATL: number
  finalTSB: number
  /** Peak CTL during plan */
  peakCTL: number
  peakCTLDate: string
  /** CTL gain from start to finish */
  ctlGain: number
  /** Projected fitness at event date (if specified) */
  eventFitness?: {
    date: string
    ctl: number
    atl: number
    tsb: number
  }
}

const CTL_TAU = 42 // days
const ATL_TAU = 7  // days

/**
 * Calculate decay factor for exponential moving average
 * factor = e^(-1/tau) ≈ 1 - 1/tau for small 1/tau
 */
function decayFactor(tau: number): number {
  return Math.exp(-1 / tau)
}

/**
 * Project fitness (CTL/ATL/TSB) forward through a series of planned training days.
 *
 * Uses the standard Performance Management Chart exponential decay model:
 *   CTL_new = CTL_old * e^(-1/42) + TSS * (1 - e^(-1/42))
 *   ATL_new = ATL_old * e^(-1/7)  + TSS * (1 - e^(-1/7))
 *   TSB = CTL - ATL
 */
export function projectFitness(
  currentCTL: number,
  currentATL: number,
  planDays: PlanDayInput[],
  options?: {
    eventDate?: string
    taperStartDate?: string
  }
): ProjectionResult {
  const ctlDecay = decayFactor(CTL_TAU)
  const atlDecay = decayFactor(ATL_TAU)
  const ctlGain = 1 - ctlDecay
  const atlGain = 1 - atlDecay

  let ctl = currentCTL
  let atl = currentATL
  let peakCTL = currentCTL
  let peakCTLDate = planDays[0]?.date ?? ''

  const points: ProjectionPoint[] = []
  let eventFitness: ProjectionResult['eventFitness'] = undefined

  // Sort plan days by date
  const sortedDays = [...planDays].sort((a, b) => a.date.localeCompare(b.date))

  // Fill in any gaps between days (rest days with TSS=0)
  const allDays: PlanDayInput[] = []
  if (sortedDays.length > 0) {
    const startDate = new Date(sortedDays[0].date)
    const endDate = new Date(sortedDays[sortedDays.length - 1].date)
    const dayMap = new Map(sortedDays.map(d => [d.date, d]))

    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
      const dateStr = d.toISOString().split('T')[0]
      allDays.push(dayMap.get(dateStr) ?? { date: dateStr, targetTSS: 0 })
    }
  }

  for (const day of allDays) {
    const tss = day.targetTSS || 0

    // Update CTL and ATL using exponential decay
    ctl = ctl * ctlDecay + tss * ctlGain
    atl = atl * atlDecay + tss * atlGain
    const tsb = ctl - atl

    // Track peak CTL
    if (ctl > peakCTL) {
      peakCTL = ctl
      peakCTLDate = day.date
    }

    const isEvent = options?.eventDate === day.date
    const isTaper = options?.taperStartDate
      ? day.date >= options.taperStartDate
      : day.phase?.toLowerCase() === 'taper'

    points.push({
      date: day.date,
      ctl: Math.round(ctl * 10) / 10,
      atl: Math.round(atl * 10) / 10,
      tsb: Math.round(tsb * 10) / 10,
      tss,
      isEvent,
      isTaper,
      phase: day.phase ?? undefined,
    })

    // Capture event day fitness
    if (isEvent) {
      eventFitness = {
        date: day.date,
        ctl: Math.round(ctl * 10) / 10,
        atl: Math.round(atl * 10) / 10,
        tsb: Math.round(tsb * 10) / 10,
      }
    }
  }

  const lastPoint = points[points.length - 1]

  return {
    points,
    finalCTL: lastPoint?.ctl ?? currentCTL,
    finalATL: lastPoint?.atl ?? currentATL,
    finalTSB: lastPoint?.tsb ?? (currentCTL - currentATL),
    peakCTL: Math.round(peakCTL * 10) / 10,
    peakCTLDate,
    ctlGain: Math.round(((lastPoint?.ctl ?? currentCTL) - currentCTL) * 10) / 10,
    eventFitness,
  }
}

/**
 * Convert plan_data from a saved training plan into PlanDayInput[] for projection.
 * Handles the structure generated by the plan generator.
 */
export function planDataToPlanDays(planData: Record<string, unknown>): PlanDayInput[] {
  const weeks = planData.weeks as Array<{
    phase?: string
    days: Array<{
      date: string
      workout?: { targetTSS?: number; category?: string } | null
    }>
  }> | undefined

  if (!weeks) return []

  return weeks.flatMap(week =>
    week.days.map(day => ({
      date: day.date,
      targetTSS: day.workout?.targetTSS ?? 0,
      workoutType: day.workout?.category ?? null,
      phase: week.phase ?? null,
    }))
  )
}
